# Redis八股文面试

### 1. redis的数据结构

基础数据结构:
> String, Hash, Set, Sorted Set, List

高级数据结构:
> **Bitmap**: 支持按bit来存储信息, 可以用来实现布隆过滤器
> **HyperLogLog**: 供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV
> **Geospatial**: 可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。
> **pub/sub**: 功能是订阅发布功能，可以用作简单的消息队列。
> **事务**: Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。
> **持久化**: Redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。
RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。
AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。

### 2. 缓存雪崩、缓存击穿、缓存穿透

1. 缓存雪崩
> **定义**: 大量的key在同一时间过期
> **解决方式**: 
> 1. 构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）
> 2. 使用锁或队列：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况
> 3. 设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。
> 4. 将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<font color="red">常用方式</font>
1. 缓存击穿
> **定义**: 大量并发请求，同时请求一个热门数据，但这个数据没有在redis中，请求都到了数据库中，可能导致数据库崩溃。  
> **解决方式**：
> 1. 预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长
> 2. 实时调整：现场监控哪些数据热门，实时调整key的过期时长
> 3. 使用锁：就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key，当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key。当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。
3. 缓存穿透
> **定义**: 大量恶意请求往服务器中查询一个不存在的数据, 导致数据库负载过高, 最终导致数据库崩溃. 
> **解决方案:**
> 1. 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟
> 2. 设置可访问的名单(白名单): 使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问. 其实缓存穿透大多数场景是在遭受恶意攻击才会遇到的. 因此也可以搞IP请求过滤. 
> 3. 采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。

> 区别**缓存击穿**和**缓存穿透** 最主要的一点是一个**透**字, **透** 意味着把缓存, 数据库都给搞透了,还是没能请求到数据.

## 3. Redis其它一些高级用法

这部分主要是我当时在爱给网(www.aigei.com)实习工作的时候用的比较多的一些东西. 主要是两点: ①借助list数据结构实现异步队列;②pub/sub实现生产者-消费者功能,主要用户处理集群间第一级缓存的数据一致性问题.  

3.1 借助list实现系统中的队列功能  
> rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。 还有另一种方式就是使用阻塞方法获取数据 blpop，在没有消息的时候，它会阻塞住直到消息到来。

3.2 借助pub/sub实现 1->N的消息队列, 类似kafka
> 当时我们系统的缓存体系是二级缓存(ehcache + redis), ehcache缓存的数据存储在本机, 当数据库中的数据发生变化之后, Redis 本来就是集群的, 数据同步比较容易, 但本机的ehcache缓存管理就需要借助Redis的广播机制, 告诉集群中的每一台机器对ehcache中的缓存进行清理(或者是更新)

> 由于Redis并不是一个专门搞队列的东西, 因此pub/sub也是存在一些缺点:
> 1. 没有 Ack 机制，也不保证数据的连续： PubSub 的生产者传递过来一个消息，Redis 会直接找到相应的消费者传递过去。如果没有一个消费者，那么消息会被直接丢弃。如果开始有三个消费者，其中一个突然挂掉了，过了一会儿等它再重连时，那么重连期间的消息对于这个消费者来说就彻底丢失了。
> 2. 不持久化消息： 如果 Redis 停机重启，PubSub 的消息是不会持久化的，毕竟 Redis 宕机就相当于一个消费者都没有，所有的消息都会被直接丢弃. 

## 4. Redis高可用

Redis 支持主从同步，提供 Cluster 集群部署模式，通过 Sentine l哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 slaveof 到新主。

选主的策略简单来说有三个：

* slave 的 priority 设置的越低，优先级越高；
* 同等情况下，slave 复制的数据越多优先级越高；
* 相同的条件下 runid 越小越容易被选中。

在 Redis 集群中，sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。

Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。
